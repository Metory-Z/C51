C51 COMPILER V9.00   PRACTICE                                                              07/15/2019 22:53:05 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE PRACTICE
OBJECT MODULE PLACED IN .\practice.obj
COMPILER INVOKED BY: D:\Exe\C51+Keil4ÕÍ√¿∞Ê\C51\BIN\C51.EXE ..\practice.c BROWSE DEBUG OBJECTEXTEND OBJECT(.\practice.ob
                    -j)

line level    source

   1          #include<reg52.h>
   2          
   3          sbit KEY_IN_1  = P2^4;
   4          sbit KEY_IN_2  = P2^5;
   5          sbit KEY_IN_3  = P2^6;
   6          sbit KEY_IN_4  = P2^7;
   7          sbit KEY_OUT_1 = P2^3;
   8          sbit KEY_OUT_2 = P2^2;
   9          sbit KEY_OUT_3 = P2^1;
  10          sbit KEY_OUT_4 = P2^0;
  11          
  12          unsigned char code KeyCodeMap[4][4] =
  13              {
  14                  {0x31,0x32,0x33,0x26}, // 1,2,3,left
  15                  {0x34,0x35,0x36,0x25}, // 4,5,6,up
  16                  {0x37,0x38,0x39,0x28}, // 7,8,9,right
  17                  {0x30,0x1B,0x0D,0x27}  // 0,Esc,Enter,down
  18              };
  19          
  20          unsigned char KeySta[4][4] = 
  21              {
  22                  {1,1,1,1}, {1,1,1,1}, {1,1,1,1}, {1,1,1,1}
  23              };
  24          
  25          unsigned long beats = 0;
  26          
  27          void KeyDriver();
  28          
  29          void main()
  30          {
  31   1          EA = 1;
  32   1          TMOD = 0x01;
  33   1          TH0 = 0xFC;
  34   1          TL0 = 0x67;// 1ms
  35   1          ET0 = 1;
  36   1          TR0 = 1;// ÂêØÂä®T0
  37   1      
  38   1          while (1)
  39   1          {
  40   2              KeyDriver();
  41   2          } 
  42   1      }
  43          
  44          void StartMotor(signed long angle)
  45          {
  46   1          EA = 0;
  47   1          beats = (angle * 4076) / 360;
  48   1          EA = 1;
  49   1      }
  50          
  51          void StopMotor()
  52          {
  53   1          EA = 0;
  54   1          beats = 0;
C51 COMPILER V9.00   PRACTICE                                                              07/15/2019 22:53:05 PAGE 2   

  55   1          EA = 1;
  56   1      }
  57          
  58          void KeyAction(unsigned char keycode)
  59          {
  60   1          static bit dirMotor = 0;// motor direction
  61   1      
  62   1          if ((keycode>=0x30) && (keycode<=0x39))
  63   1          {
  64   2              if (dirMotor == 0)
  65   2                  StartMotor(360*(keycode-0x30));
  66   2              else
  67   2                  StartMotor(-360*(keycode-0x30));
  68   2              
  69   2          }
  70   1          else if (keycode == 0x26)
  71   1          {
  72   2              dirMotor = 0;// up -> clockwise
  73   2          }
  74   1          else if (keycode == 0x28)
  75   1          {
  76   2              dirMotor = 1;// down -> anticlockwise
  77   2          }
  78   1          else if (keycode == 0x25)
  79   1          {
  80   2              StartMotor(90);// left -> clockwise 90 degree
  81   2          }
  82   1          else if (keycode == 0x27)
  83   1          {
  84   2              StartMotor(-90);// right -> anticlockwise 90 degree
  85   2          }
  86   1          else if (keycode == 0x1B)
  87   1          {
  88   2              StopMotor();
  89   2          }
  90   1      }
  91          
  92          void KeyDriver()
  93          {
  94   1          // Âà§Êñ≠Âì™‰∏™ÊåâÈîÆÊúâÂä®‰Ωú,ÊâßË°åKeyAction()
  95   1          unsigned char i, j;
  96   1          static unsigned char backup[4][4] = 
  97   1          {
  98   1              {1,1,1,1}, {1,1,1,1}, {1,1,1,1}, {1,1,1,1}
  99   1          };
 100   1      
 101   1          for (i=0; i<4; i++)
 102   1          {
 103   2              for (j=0; j<4; j++)
 104   2              {
 105   3                  if (backup[i][j] != KeySta[i][j])
 106   3                  {
 107   4                      if (backup[i][j] != 0)
 108   4                      {
 109   5                          KeyAction(KeyCodeMap[i][j]);
 110   5                      }
 111   4                      backup[i][j] = KeySta[i][j];
 112   4                  }
 113   3              }
 114   2          }
 115   1      }
 116          
C51 COMPILER V9.00   PRACTICE                                                              07/15/2019 22:53:05 PAGE 3   

 117          void KeyScan()
 118          {
 119   1          
 120   1          // Ëé∑Âèñ4Ê¨°Êâ´ÊèèÂÄºÔºåÊâßË°åKeyDriver()
 121   1          unsigned char i;
 122   1          static unsigned char keyout = 0;
 123   1          static unsigned char keybuf[4][4] = 
 124   1          {
 125   1              {0xFF, 0xFF, 0xFF, 0xFF}, 
 126   1              {0xFF, 0xFF, 0xFF, 0xFF}, 
 127   1              {0xFF, 0xFF, 0xFF, 0xFF}, 
 128   1              {0xFF, 0xFF, 0xFF, 0xFF}
 129   1          };
 130   1      
 131   1          keybuf[keyout][0] = (keybuf[keyout][0] << 1) | KEY_IN_1;
 132   1          keybuf[keyout][1] = (keybuf[keyout][1] << 1) | KEY_IN_2;
 133   1          keybuf[keyout][2] = (keybuf[keyout][2] << 1) | KEY_IN_3;
 134   1          keybuf[keyout][3] = (keybuf[keyout][3] << 1) | KEY_IN_4; 
 135   1          
 136   1          for (i=0; i<4; i++)
 137   1          {
 138   2              if ((keybuf[keyout][i] & 0x0F) == 0x00)
 139   2                  KeySta[keyout][i] = 0;
 140   2              else if ((keybuf[keyout][i] & 0x0F) == 0x0F)
 141   2                  KeySta[keyout][i] = 1;
 142   2          }
 143   1          keyout++;
 144   1          keyout = keyout & 0x03;
 145   1          // ÂΩìkeyout Á≠â‰∫é4(100) Êó∂Ôºå‰∏é0x03(011) ÂÅö‰∏éËøêÁÆóÂêéÔºåÂΩíÈõ∂
 146   1          switch(keyout)
 147   1          {
 148   2              // ÂÖàÊâ´ÊèèKeyInÔºåÂêéÂàáÊç¢KeyOut
 149   2              case 0: KEY_OUT_4 = 1; KEY_OUT_1 = 0;break;
 150   2              case 1: KEY_OUT_1 = 1; KEY_OUT_2 = 0;break;
 151   2              case 2: KEY_OUT_2 = 1; KEY_OUT_3 = 0;break;
 152   2              case 3: KEY_OUT_3 = 1; KEY_OUT_4 = 0;break;
 153   2              default: break;
 154   2          }
 155   1      }
 156          
 157          void TurnMotor()
 158          {
 159   1          unsigned char tmp;
 160   1          static unsigned char index = 0;
 161   1          unsigned char code BeatCode[8] = {
 162   1              0xE, 0xC, 0xD, 0x9, 0xB, 0x3, 0x7, 0x6
 163   1          };
 164   1      
 165   1          if (beats != 0)
 166   1          {
 167   2              if (beats > 0)
 168   2              {
 169   3                  index++;
 170   3                  index = index & 0x07;
 171   3                  beats--;
 172   3              }
 173   2              else
 174   2              {
 175   3                  index--;
 176   3                  index = index & 0x07;
 177   3                  beats++;
 178   3              }
C51 COMPILER V9.00   PRACTICE                                                              07/15/2019 22:53:05 PAGE 4   

 179   2              tmp = P1;
 180   2              tmp = tmp & 0xF0;
 181   2              tmp = tmp | BeatCode[index];
 182   2              P1 = tmp;
 183   2          }
 184   1          else
 185   1              P1 = P1 | 0x0F;
 186   1      }
 187          
 188          void InterruptTimer0() interrupt 1
 189          {
 190   1          static bit div = 0;
 191   1      
 192   1          TH0 = 0xFC;
 193   1          TL0 = 0x67;
 194   1          KeyScan();
 195   1          div = ~div;
 196   1          if (div == 1)
 197   1              TurnMotor();// ÂÆöÊó∂1ms, Ê≠•ËøõÁîµÊú∫ÈúÄË¶Å2ms
 198   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    710    ----
   CONSTANT SIZE    =     24    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     54       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
